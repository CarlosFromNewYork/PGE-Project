--- SDL_audiotypecvt_old.c
+++ SDL_audiotypecvt.c
@@ -216,19 +216,31 @@
     }
 }
 
+/* Works a bit glitchy, need to more work on it for Arbitrary resapling! */
+#define TRY_INTERPOLATE_ARBITRARY
+/* Without it sound is a bit "metallic" after up-sampling and some down-sampling,
+   but stable and no clicks and no clips */
+
 void
 SDL_Upsample_Arbitrary(SDL_AudioCVT *cvt, const int channels)
 {
-    const int srcsize = cvt->len_cvt - (64 * channels);
-    const int dstsize = (int) (((double)(cvt->len_cvt/(channels*4))) * cvt->rate_incr) * (channels*4);
-    register int eps = 0;
-    float *dst = ((float *) (cvt->buf + dstsize)) - channels;
-    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - channels;
-    const float *target = ((const float *) cvt->buf);
     const size_t cpy = sizeof (float) * channels;
+    int s_size = cvt->len_cvt / cpy;
+    int d_size = (int)(((double)s_size) * cvt->rate_incr);
+    float *target = ((float *) cvt->buf);
+          float *dst = target + (d_size * channels) - channels;
+    const float *src = target + (s_size * channels) - channels;
+
+    #ifdef TRY_INTERPOLATE_ARBITRARY
     float last_sample[8];
+    #endif
     float sample[8];
-    int i;
+    #ifdef TRY_INTERPOLATE_ARBITRARY
+    int i;
+    #endif
+
+    double eps      = 0.0;
+    double offset   = 1.0 / cvt->rate_incr;
 
 #if DEBUG_CONVERT
     fprintf(stderr, "Upsample arbitrary (x%f), %d channels.\n", cvt->rate_incr, channels);
@@ -237,66 +249,85 @@
     SDL_assert(channels <= 8);
 
     SDL_memcpy(sample, src, cpy);
+    #ifdef TRY_INTERPOLATE_ARBITRARY
     SDL_memcpy(last_sample, src, cpy);
+    #endif
 
     while (dst > target) {
         SDL_memcpy(dst, sample, cpy);
         dst -= channels;
-        eps += srcsize;
-        if ((eps << 1) >= dstsize) {
+        eps += offset;
+        if(eps >= 1.0) {
             src -= channels;
+            #ifndef TRY_INTERPOLATE_ARBITRARY
+            SDL_memcpy(sample, src, cpy);
+            #else
+            for (i = 0; i < channels; i++) {
+                sample[i] = (float)( (((double) src[i]) + ((double) last_sample[i])) * 0.5);
+            }
+            SDL_memcpy(last_sample, sample, cpy);
+            #endif
+            eps -= 1.0;
+        }
+    }
+
+    cvt->len_cvt = d_size * cpy;
+    if (cvt->filters[++cvt->filter_index]) {
+        cvt->filters[cvt->filter_index](cvt, AUDIO_F32SYS);
+    }
+}
+
+void
+SDL_Downsample_Arbitrary(SDL_AudioCVT *cvt, const int channels)
+{
+    const size_t cpy = sizeof(float) * channels;
+    int s_size = cvt->len_cvt / cpy;
+    int d_size = (int)(((double)s_size) * cvt->rate_incr);
+    float *dst = (float *)cvt->buf;
+    const float *src = (float *)cvt->buf;
+    const float *target = src + (s_size * channels);
+
+    #ifdef TRY_INTERPOLATE_ARBITRARY
+    float last_sample[8];
+    #endif
+    float sample[8];
+    #ifdef TRY_INTERPOLATE_ARBITRARY
+    int i;
+    #endif
+
+    double eps     = 0.0;
+    double offset  = cvt->rate_incr;
+
+#if DEBUG_CONVERT
+    fprintf(stderr, "Downsample arbitrary (x%f), %d channels.\n", cvt->rate_incr, channels);
+#endif
+
+    SDL_assert(channels <= 8);
+
+    SDL_memcpy(sample, src, cpy);
+    #ifdef TRY_INTERPOLATE_ARBITRARY
+    SDL_memcpy(last_sample, src, cpy);
+    #endif
+
+    while(dst < target) {
+        src += channels;
+        eps += offset;
+        if(eps >= 1.0) {
+            SDL_memcpy(dst, sample, cpy);
+            dst += channels;
+            #ifndef TRY_INTERPOLATE_ARBITRARY
+            SDL_memcpy(sample, src, cpy);
+            #else
             for (i = 0; i < channels; i++) {
                 sample[i] = (float) ((((double) src[i]) + ((double) last_sample[i])) * 0.5);
             }
             SDL_memcpy(last_sample, sample, cpy);
-            eps -= dstsize;
-        }
-    }
-
-    cvt->len_cvt = dstsize;
-    if (cvt->filters[++cvt->filter_index]) {
-        cvt->filters[cvt->filter_index](cvt, AUDIO_F32SYS);
-    }
-}
-
-void
-SDL_Downsample_Arbitrary(SDL_AudioCVT *cvt, const int channels)
-{
-    const int srcsize = cvt->len_cvt - (64 * channels);
-    const int dstsize = (int) (((double)(cvt->len_cvt/(channels*4))) * cvt->rate_incr) * (channels*4);
-    register int eps = 0;
-    float *dst = (float *) cvt->buf;
-    const float *src = (float *) cvt->buf;
-    const float *target = (const float *) (cvt->buf + dstsize);
-    const size_t cpy = sizeof (float) * channels;
-    float last_sample[8];
-    float sample[8];
-    int i;
-
-#if DEBUG_CONVERT
-    fprintf(stderr, "Downsample arbitrary (x%f), %d channels.\n", cvt->rate_incr, channels);
-#endif
-
-    SDL_assert(channels <= 8);
-
-    SDL_memcpy(sample, src, cpy);
-    SDL_memcpy(last_sample, src, cpy);
-
-    while (dst < target) {
-        src += 8;
-        eps += dstsize;
-        if ((eps << 1) >= srcsize) {
-            SDL_memcpy(dst, sample, cpy);
-            dst += 8;
-            for (i = 0; i < channels; i++) {
-                sample[i] = (float) ((((double) src[i]) + ((double) last_sample[i])) * 0.5);
-            }
-            SDL_memcpy(last_sample, sample, cpy);
-            eps -= srcsize;
-        }
-    }
-
-    cvt->len_cvt = dstsize;
+            #endif
+            eps -= 1.0;
+        }
+    }
+
+    cvt->len_cvt = d_size * cpy;
     if (cvt->filters[++cvt->filter_index]) {
         cvt->filters[cvt->filter_index](cvt, AUDIO_F32SYS);
     }
@@ -305,11 +336,13 @@
 void
 SDL_Upsample_x2(SDL_AudioCVT *cvt, const int channels)
 {
-    const int dstsize = cvt->len_cvt * 2;
-    float *dst = ((float *) (cvt->buf + dstsize)) - (channels * 2);
-    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - channels;
-    const float *target = ((const float *) cvt->buf);
     const size_t cpy = sizeof (float) * channels;
+    int s_size = cvt->len_cvt / cpy;
+    int d_size = s_size * 2;
+    float *target = ((float *) cvt->buf);
+          float *dst = target + (d_size * channels) - channels;
+    const float *src = target + (s_size * channels) - channels;
+
     float last_sample[8];
     int i;
 
@@ -331,7 +364,7 @@
         dst -= channels;
     }
 
-    cvt->len_cvt = dstsize;
+    cvt->len_cvt = d_size * cpy;
     if (cvt->filters[++cvt->filter_index]) {
         cvt->filters[cvt->filter_index](cvt, AUDIO_F32SYS);
     }
@@ -340,11 +373,13 @@
 void
 SDL_Upsample_x4(SDL_AudioCVT *cvt, const int channels)
 {
-    const int dstsize = cvt->len_cvt * 4;
-    float *dst = ((float *) (cvt->buf + dstsize)) - (channels * 4);
-    const float *src = ((float *) (cvt->buf + cvt->len_cvt)) - channels;
-    const float *target = ((const float *) cvt->buf);
     const size_t cpy = sizeof (float) * channels;
+    int s_size = cvt->len_cvt / cpy;
+    int d_size = s_size * 4;
+    float *target = ((float *) cvt->buf);
+          float *dst = target + (d_size * channels) - channels;
+    const float *src = target + (s_size * channels) - channels;
+
     float last_sample[8];
     int i;
 
@@ -374,7 +409,7 @@
         src -= channels;
     }
 
-    cvt->len_cvt = dstsize;
+    cvt->len_cvt = d_size * cpy;
     if (cvt->filters[++cvt->filter_index]) {
         cvt->filters[cvt->filter_index](cvt, AUDIO_F32SYS);
     }
@@ -383,11 +418,13 @@
 void
 SDL_Downsample_Multiple(SDL_AudioCVT *cvt, const int multiple, const int channels)
 {
-    const int dstsize = cvt->len_cvt / multiple;
-    float *dst = (float *) cvt->buf;
-    const float *src = (float *) cvt->buf;
-    const float *target = (const float *) (cvt->buf + dstsize);
-    const size_t cpy = sizeof (float) * channels;
+    const size_t cpy = sizeof(float) * channels;
+    int s_size = cvt->len_cvt / cpy;
+    int d_size = s_size / multiple;
+    float *dst = (float *)cvt->buf;
+    const float *src = (float *)cvt->buf;
+    const float *target = src + (s_size * channels);
+
     float last_sample[8];
     int i;
 
@@ -408,7 +445,7 @@
         src += (channels * multiple);
     }
 
-    cvt->len_cvt = dstsize;
+    cvt->len_cvt = d_size * cpy;
     if (cvt->filters[++cvt->filter_index]) {
         cvt->filters[cvt->filter_index](cvt, AUDIO_F32SYS);
     }
