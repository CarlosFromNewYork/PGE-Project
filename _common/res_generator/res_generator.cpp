#include <cstdio>
#include <string>
#include <vector>
#include <ini_processing.h>

const char* splash =    "/*****************************************************************\n"
                        "     Automatically generated by _common/res_generator utility\n"
                        "     Suggested to DONT EDIT THIS\n"
                        "     Edit the _common/res_generator/res_generator.cpp instead\n"
                        " *****************************************************************/\n\n";

struct FileEntry
{
    std::string name;
    std::string path;
    unsigned long size;
};

int main(int argc, char**argv)
{
    IniProcessing ini;
    std::string folderAt = "../../Engine/_resources/";
    std::string iniFile = "resource.ini";
    
    ini.open(folderAt + iniFile);
    unsigned int count = 0;
    ini.beginGroup("resources");
    ini.read("count", count, 0);
    ini.endGroup();

    if(count==0)
    {
        printf("Nothing to do! (zero count)\n");
        return 1;
    }

    std::vector<FileEntry> files;

    for(unsigned int i=0; i<count; i++)
    {
        std::string name;
        std::string path;
        ini.beginGroup("file-" + std::to_string(i));
        ini.read("name", name, "");
        ini.read("path", path, "");
        ini.endGroup();

        files.push_back({name, folderAt + path, 0});
    }

    std::string outH     = folderAt + "resource.h";
    std::string outHdata = folderAt + "resource_data.h";
    std::string outC     = folderAt + "resource.cpp";
    FILE* outh = fopen(outH.c_str(), "wb");
    FILE* outd = fopen(outHdata.c_str(), "wb");
    FILE* outc = fopen(outC.c_str(), "wb");

    if(!outh || !outd || !outc)
    {
        printf("CAN'T OPEN FILES FOR WRITE\n");
        return 1;
    }

    fprintf(outc, "%s", splash);
    fprintf(outd, "%s", splash);
    fprintf(outh, "%s", splash);

    unsigned int fileCount = 0;

    fprintf(outc,   "#include <stdio.h>\n"
                    "#include <string>\n"
                    "#include \"resource_data.h\"\n"
                    "#include \"resource.h\"\n"
                    "\n");

    fprintf(outd,   "#include <unordered_map>\n\n"
                    "struct FileEntry{\n"
                    "   const unsigned char*array;\n"
                    "   size_t size;\n"
                    "};\n\n");

    for(unsigned long i=0; i<files.size(); i++, fileCount++)
    {
        FileEntry& it = files[i];
        unsigned long fileSize = 0;
        fprintf(outd, "// %s\nstatic const unsigned char file_%d[] = \n{\n    ", it.name.c_str(), fileCount);
        FILE* ps = fopen(it.path.c_str(), "rb");
        if(!ps)
        {
            printf("FAILED TO OPEN FILE %s", it.path.c_str());
            continue;
        }
        int c;
        int breaker = 0;
        while( (c = fgetc(ps)) != -1 )
        {
            fprintf(outd, " 0x%02X,", static_cast<unsigned int>(c));
            fileSize++;
            breaker++;
            if(breaker>=10)
            {
                fprintf(outd, "\n    ");
                breaker = 0;
            }
        }
        fprintf(outd, " 0x00");
        fclose(ps);
        it.size = fileSize;
        fprintf(outd, "\n};\n\n");
    }

    fprintf(outd, "// List of availalbe resource files\nstatic std::unordered_map<std::string, FileEntry> filesMap = \n{\n");
    for(unsigned long i=0; i<files.size(); i++, fileCount++)
    {
        FileEntry& it = files[i];
        fprintf(outd, "\t{\"%s\",\t{file_%lu,\t%lu}},\n", it.name.c_str(), i, it.size);
    }
    fprintf(outd, "};\n\n\n");

    /*
    fprintf(outc,   "FILE* RES_open(const char* file)\n{\n"
                    "   std::unordered_map<std::string, FileEntry>::iterator f = filesMap.find(file);\n"
                    "   if(f == filesMap.end())\n"
                    "       return nullptr;\n\n"
                    "   FileEntry& e = f->second;\n"
                    "   return fmemopen(reinterpret_cast<void*>(const_cast<unsigned char*>(e.array)), e.size, \"rb\");\n"
                    "}\n\n");
    */ //Windows OS is totally sucks because fmemopen() isn't implemented on the kernel

    fprintf(outc,   "void RES_getMem(const char* file, char* &mem, size_t &size)\n{\n"
                    "   std::unordered_map<std::string, FileEntry>::iterator f = filesMap.find(file);\n"
                    "   if(f == filesMap.end())\n"
                    "       throw(\"Resource doesn't exists!\");\n\n"
                    "   FileEntry& e = f->second;\n"
                    "   mem = const_cast<char*>(reinterpret_cast<const char*>(e.array));\n"
                    "   size = e.size;\n"
                    "}\n\n");

    fprintf(outh, "#include <stdio.h>\n\n");
    //fprintf(outh, "extern FILE* RES_open(const char* file);\n");
    fprintf(outh,   "/**\n"
                    " * @brief Get memory pointer and block size to resource file\n"
                    " * @param [IN] file name of resource file\n"
                    " * @param [OUT] mem reference to null pointer\n"
                    " * @param [OUT] size reference to size variable\n"
                    " */\n"
                    "extern void RES_getMem(const char* file, char* &mem, size_t &size);\n\n");

    fclose(outh);
    fclose(outc);

    printf("All %d resources has being built!\n", count);

    return 0;
}
