/*
 * RES_Generator - A small resource generator which converts list of files
 * into C++ arrays are can be accessible via friendly functions
 *
 * Copyright (c) 2018 Vitaly Novichkov <admin@wohlnet.ru>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include <cstdio>
#include <string>
#include <vector>
#include <ini_processing.h>

const char* splash =    "/*****************************************************************\n"
                        "     Automatically generated by _common/res_generator utility\n"
                        "     Suggested to DONT EDIT THIS\n"
                        "     Edit the _common/res_generator/res_generator.cpp instead\n"
                        " *****************************************************************/\n\n";

struct FileEntry
{
    std::string name;
    std::string path;
    unsigned long size;
};

int main(int argc, char**argv)
{
    IniProcessing ini;
    std::string folderAt = "../../Engine/_resources/";
    std::string iniFile = "resource.ini";

    ini.open(folderAt + iniFile);
    unsigned int count = 0;
    ini.beginGroup("resources");
    ini.read("count", count, 0);
    ini.endGroup();

    if(count==0)
    {
        printf("Nothing to do! (zero count)\n");
        return 1;
    }

    std::vector<FileEntry> files;

    for(unsigned int i=0; i<count; i++)
    {
        std::string name;
        std::string path;
        ini.beginGroup("file-" + std::to_string(i));
        ini.read("name", name, "");
        ini.read("path", path, "");
        ini.endGroup();

        files.push_back({name, folderAt + path, 0});
    }

    std::string outH     = folderAt + "resource.h";
    std::string outHdata = folderAt + "resource_data.h";
    std::string outC     = folderAt + "resource.cpp";
    FILE* outh = fopen(outH.c_str(), "wb");
    FILE* outd = fopen(outHdata.c_str(), "wb");
    FILE* outc = fopen(outC.c_str(), "wb");

    if(!outh || !outd || !outc)
    {
        printf("CAN'T OPEN FILES FOR WRITE\n");
        return 1;
    }

    fprintf(outc, "%s", splash);
    fprintf(outd, "%s", splash);
    fprintf(outh, "%s", splash);

    unsigned int fileCount = 0;

    fprintf(outc,   "#include <stdio.h>\n"
                    "#include <string>\n"
                    "#include \"resource_data.h\"\n"
                    "#include \"resource.h\"\n"
                    "\n");

    fprintf(outd,   "#include <unordered_map>\n\n"
                    "struct FileEntry{\n"
                    "   unsigned char*array;\n"
                    "   size_t size;\n"
                    "};\n\n");

    for(unsigned long i=0; i<files.size(); i++, fileCount++)
    {
        FileEntry& it = files[i];
        fprintf(outd,   "// %s\n"
                        "static unsigned char file_%d[] =\n"
                        "{\n    ", it.name.c_str(), fileCount);
        FILE* ps = fopen(it.path.c_str(), "rb");
        if(!ps)
        {
            printf("FAILED TO OPEN FILE %s\n", it.path.c_str());
            continue;
        }
        int c;
        int breaker = 0;
        unsigned long fileSize = 0;
        while( (c = fgetc(ps)) != -1 )
        {
            fprintf(outd, " 0x%02X,", static_cast<unsigned int>(c));
            fileSize++;
            breaker++;
            if(breaker>=10)
            {
                fprintf(outd, "\n    ");
                breaker = 0;
            }
        }
        fprintf(outd, " 0x00");
        fclose(ps);
        it.size = fileSize;
        fprintf(outd, "\n};\n\n");
    }

    fprintf(outd,   "// List of availalbe resource files\n"
                    "static std::unordered_map<std::string, FileEntry> filesMap =\n"
                    "{\n");
    for(unsigned long i=0; i<files.size(); i++, fileCount++)
    {
        FileEntry& it = files[i];
        fprintf(outd, "    {\"%s\",\t{file_%lu,%8lu}},\n", it.name.c_str(), i, it.size);
    }
    fprintf(outd, "};\n\n");

    /*
    fprintf(outc,   "FILE* RES_open(const char* file)\n{\n"
                    "   std::unordered_map<std::string, FileEntry>::iterator f = filesMap.find(file);\n"
                    "   if(f == filesMap.end())\n"
                    "       return nullptr;\n\n"
                    "   FileEntry& e = f->second;\n"
                    "   return fmemopen(reinterpret_cast<void*>(const_cast<unsigned char*>(e.array)), e.size, \"rb\");\n"
                    "}\n\n");
    */ //Windows OS is totally sucks because fmemopen() isn't implemented on the kernel

    fprintf(outc,   "bool RES_getMem(const char* file, unsigned char* &mem, size_t &size)\n{\n"
                    "   std::unordered_map<std::string, FileEntry>::iterator f = filesMap.find(file);\n"
                    "   if(f == filesMap.end())\n"
                    "       return false;\n\n"
                    "   FileEntry& e = f->second;\n"
                    "   mem = e.array;\n"
                    "   size = e.size;\n"
                    "   return true;\n"
                    "}\n\n");

    fprintf(outh, "#include <stdio.h>\n\n");
    //fprintf(outh, "extern FILE* RES_open(const char* file);\n");
    fprintf(outh,   "/**\n"
                    " * @brief Get memory pointer and block size to resource file\n"
                    " * @param [IN] file name of resource file\n"
                    " * @param [OUT] mem reference to null pointer\n"
                    " * @param [OUT] size reference to size variable\n"
                    " */\n"
                    "extern bool RES_getMem(const char* file, unsigned char* &mem, size_t &size);\n\n");

    fclose(outh);
    fclose(outc);

    printf("All %d resources has being built!\n", count);

    return 0;
}

